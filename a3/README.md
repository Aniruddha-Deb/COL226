# COL226 Assignment 3

In this assignment, we implement a AST generator (sans type checking) for WHILE.

## Context-Free Grammar

(nonterminals are in `lowercase`, terminals are in `UPPERCASE`, in line with 
what is used in the code. Both nonterminals and terminals have more than one
character in their names)

```
prog -> PROGRAM IDENTIFIER BLOCKSTART declist cmdseq

declist -> dec SEMICOLON declist | ε
dec -> VAR varlist COLON INT | VAR varlist COLON BOOL
varlist -> IDENTIFIER COMMA varlist | IDENTIFIER

cmdseq -> LBRACE cmdlist RBRACE
cmdlist -> cmd SEMICOLON cmdlist | ε
cmd -> READ IDENTIFIER | 
       WRITE expr |
       IDENTIFIER ASSIGN expr |
       IF expr THEN cmdseq ELSE cmdseq ENDIF |
       WHILE expr DO cmdseq ENDWH

expr -> expr OR bexp | bexp
bexp -> bexp AND bexp' | bexp'
bexp' -> TRUE | FALSE | NOT bexp' | cmp | iexp |
cmp -> cmp EQ cmp' | cmp'
cmp' -> cmp' NE cmp2 | cmp2
cmp2 -> cmp2 LE cmp3 | cmp3
cmp3 -> cmp3 LT cmp4 | cmp4
cmp4 -> cmp4 GE cmp5 | cmp5
cmp5 -> cmp5 GT cmp6 | cmp6
cmp6 -> iexp ADD iexp' | iexp'
iexp' -> iexp' SUB iexp2 | iexp2
iexp2 -> iexp2 MUL iexp3 | iexp3
iexp3 -> iexp3 DIV iexp4 | iexp4
iexp4 -> iexp4 MOD iexp5 | iexp5
iexp5 -> ADD NUM | UMINUS NUM | IDENTIFIER | LPAREN expr RPAREN
```

## AST Datatype definition

The AST is defined slightly differently than mentioned in the assignment. Namely,
the AST uses lists too rather than merely a tree structure. This makes representing
sequences of commands and variable definitions much easier. The type definition
of the AST is as follows:

```
datatype PROG  = PROG of (DEC list)*(CMD list)
and      DEC   = INT of string | BOOL of string 
and      CMD   = RD of string | WR of EXPR | WH of EXPR*(CMD list) | 
                ITE of EXPR*(CMD list)*(CMD list) | SETINT of string*EXPR |
                SETBOOL of string*EXPR
and      EXPR  = ADD of EXPR*EXPR | SUB of EXPR*EXPR | 
                MUL of EXPR*EXPR | DIV of EXPR*EXPR | 
                MOD of EXPR*EXPR | NUM of int | IREF of string |
                OR of EXPR*EXPR | AND of EXPR*EXPR | NOT of EXPR |
                LT of EXPR*EXPR | GT of EXPR*EXPR | GE of EXPR*EXPR |
                LE of EXPR*EXPR | EQ of EXPR*EXPR | NE of EXPR*EXPR |
                TRUE | FALSE | BREF of string
```

A While program's AST root node is `PROG`, which has a list of declarations and 
a list of commands. A Declaration can be either an int, or a boolean, with an 
identifier. A command is as specified in the EBNF specification. Expressions
are simple binary operations (unary in the case of NOT) that combine both integer
and boolean expressions. This is done for several reasons, which are mentioned 
in § other design decisions.

## Syntax Directed Translation

The Semantic rules for the grammar are as follows (this can also be interpreted
from the YACC file). Each semantic declaration represents the root of the AST
generated by that rule.

NOTE: the expressions in capitals inside the semantic rules represent the datatypes
of the nodes, rather than the tokens. There are some name clashes (INT, BOOL are
both tokens and node datatypes). In practice, this is (messily?) rectified by
prefixing `TOK_` to all the tokens and leaving the AST datatypes as is to 
avoid collisions

NOTE 2: the definitions of `set`, `prependAll` and `makeVarList` are given in § Other
Implementation Decisions. In short, `prependAll` prepends all the variable declations
in that line (a line may have multiple variable declarations, eg `var x,y,z: int`)
to the main variable list, and `makeVarList` constructs that list of variable
declarations from a list of identifiers. `set` makes an 

```
prog -> PROGRAM IDENTIFIER BLOCKSTART declist cmdseq { PROG (declist, cmdseq) }

declist -> dec SEMICOLON declist { prependAll dec declist }
         | ε                     { [] }
dec -> VAR varlist COLON INT  { makeVarList varlist INT }
     | VAR varlist COLON BOOL { makeVarList varlist BOOL }
varlist -> IDENTIFIER COMMA varlist { IDENTIFIER.value :: varlist }
         | IDENTIFIER               { [IDENTIFIER.value] }

cmdseq -> LBRACE cmdlist RBRACE { cmdlist }
cmdlist -> cmd SEMICOLON cmdlist { cmd :: cmdlist }
         | ε                     { [] }
cmd -> READ IDENTIFIER { RD IDENTIFIR.value }
     | WRITE expr      { WR expr }
     | IDENTIFIER ASSIGN expr { set IDENTIFIER.value expr }
     | IF expr THEN cmdseq ELSE cmdseq ENDIF { ITE (expr,cmdseq1,cmdseq2) }
     | WHILE expr DO cmdseq ENDWH { WH (expr,cmdseq) }

expr -> expr OR bexp { OR (expr, bexp) }
      | bexp { bexp }
bexp -> bexp AND bexp' { AND (bexp, bexp') }
      | bexp' { bexp' }
bexp' -> TRUE {TRUE}
      | FALSE {FALSE}
      | NOT bexp' {NOT bexp'}
      | cmp  {cmp}
      | iexp {iexp}
cmp -> cmp EQ cmp' {EQ (cmp,cmp')}
     | cmp' {cmp'}
cmp' -> cmp' NE cmp2 {NE (cmp',cmp2)}
     | cmp2 {cmp2}
cmp2 -> cmp2 LE cmp3 {LE (cmp2,cmp3)}
     | cmp3 {cmp3}
cmp3 -> cmp3 LT cmp4 {LT (cmp3,cmp4)}
     | cmp4 {cmp4}
cmp4 -> cmp4 GE cmp5 {GE (cmp4,cmp5)}
     | cmp5 {cmp5}
cmp5 -> cmp5 GT cmp6 {GT (cmp5,cmp6)}
     | cmp6 {cmp6}
cmp6 -> iexp ADD iexp' {ADD (iexp,iexp')}
     | iexp' {iexp'}
iexp' -> iexp' SUB iexp2 {SUB (iexp',iexp2)}
     | iexp2 {iexp2}
iexp2 -> iexp2 MUL iexp3 {MUL (iexp2,iexp3)}
     | iexp3 {iexp3}
iexp3 -> iexp3 DIV iexp4 {DIV (iexp3,iexp4)}
     | iexp4 {iexp4}
iexp4 -> iexp4 MOD iexp5 {MOD (iexp4,iexp5)}
     | iexp5 {iexp5}
iexp5 -> ADD NUM {NUM NUM.value}
     | UMINUS NUM {NUM (-1*NUM.value)}
     | IDENTIFIER {if SymbolTable[ref] = INT then IREF IDENTIFIER else BREF IDENTIFIER}
     | LPAREN expr RPAREN {expr}
```

## Auxiliary Functions and Data
The `DataTypes` structure defined above was used across the parser and lexer. 
`glue.sml` defines some glue code that ties in the lexer and parser to get them
to work together, and `compiler.sml` contains the main While compiler that is
used to compile source files. Files are passed in by calling the function 
`While.compile "<filename>";`. Compilation is handled by `while.cm`, a compilation
manager file, which is invoked by typing in `CM.make "while.cm";`. 

## Usage
open up the SML interpreter:

```sml```

Set the control print depth to a larger number (this allows seeing the printed tree)

```- Control.Print.printDepth := 100;```

Compile the lex/yacc files using CM.make:

```- CM.make "while.cm";```

After successfully compiling, call the compiler on the file whose AST is
to be generated

```While.compile "<filename>";```

If all goes well, you should see an output similar to the following (this is 
the output for `test2.while`

```
val it =
  PROG
    ([INT "word1",INT "word2",INT "id",INT "x",INT "y",INT "z",BOOL "a",
      BOOL "b",BOOL "c"],
     [WH
        (AND (LT (IREF "x",IREF "y"),LT (BREF "a",BREF "b")),
         [SETINT ("x",NUM 5),SETINT ("y",SUB (IREF "z",NUM 3)),
          SETINT ("z",SUB (IREF "z",NUM 1)),
          SETBOOL ("a",OR (BREF "b",BREF "c"))]),
      ITE (EQ (IREF "x",NUM 5),[SETINT ("y",NUM 2)],[SETINT ("y",NUM 3)])])
  : ?.DataTypes.PROG
```

## Other Design Decisions

There are two primary design decisions taken here:
1. *Unified integer and Boolean expression*: This decision was taken to avoid 
   reduce/reduce conflicts in the parser. Parsing of expressions is context 
   dependent (an integer assignment needs an integer expression, a boolean one 
   a boolean expression). In addition, the relational operators are polymorphic,
   and also operate on boolean types. This would be handled in a later stage, hence
   at this stage, all we do is unify the expression, and let the evaluator raise
   evaluation errors as and when the expression is evaluated and a type is returned
2. *Symbol Table Impelmentation*: The symbol table maps an identifier to a type,
   and will be used to determine the return type of expressions in the language
   at runtime (in a later stage).

Other design decisions are self-explanatory: the AST datatype incorporates references and assignment variable types, to make semantic analysis easier for the next stages.

## Other Implementation Decisions

The implementations of `makeVarList`, `prependAll` and `set` are as below:

```
fun makeVarList (l::L) t = (
        SymbolTable := update (!SymbolTable) l (t l);
        (t l)::(makeVarList L t))
  | makeVarList []     t = []

fun prependAll (l::L) L' = l::(prependAll L L')
  | prependAll []     L' = L'

fun set id expr =
    case lookup (!SymbolTable) id of 
        (INT s) => SETINT (id, expr)
      | (BOOL b) => SETBOOL (id, expr)
```

`SymbolTable` is a dictionary of type `string*DEC`. The Glue code in `glue.sml` creates the WhileParser, while the structure in `compiler.sml` is the final compiler, that compiles the code. `ml-yacc` uses a predictive parser, hence it can change the values of certain tokens or insert tokens where neccessary to fit the rules, eg a missing semicolon or brace. 

## Acknowledgements

Most of the work here used the framework and design for the pi-calculus parser
in the [User's Guide to ML-Lex and ML-Yacc](http://rogerprice.org/ug/ug.pdf) by 
[Roger Price](http://rogerprice.org/). The `Dictionary` structure used for the Symbol Table was created by Yamatodani Kiyoshi of Tohoku University. 


# COL226 Assignment 3

In this assignment, we implement a AST generator (sans type checking) for WHILE.

## Context-Free Grammar

(nonterminals are in `lowercase`, terminals are in `UPPERCASE`, in line with 
what is used in the code. Both nonterminals and terminals have more than one
character in their names)

```
prog -> PROGRAM IDENTIFIER BLOCKSTART declist cmdseq

declist -> dec SEMICOLON declist | ε
dec -> VAR varlist COLON INT | VAR varlist COLON BOOL
varlist -> IDENTIFIER COMMA varlist | IDENTIFIER

cmdseq -> LBRACE cmdlist RBRACE
cmdlist -> cmd SEMICOLON cmdlist | ε
cmd -> READ IDENTIFIER | 
       WRITE expr |
       IDENTIFIER ASSIGN expr |
       IF expr THEN cmdseq ELSE cmdseq ENDIF |
       WHILE expr DO cmdseq ENDWH

expr -> expr OR bexp | bexp
bexp -> bexp AND bexp' | bexp'
bexp' -> TRUE | FALSE | NOT bexp' | cmp | iexp |
cmp -> cmp EQ cmp' | cmp'
cmp' -> cmp' NE cmp2 | cmp2
cmp2 -> cmp2 LE cmp3 | cmp3
cmp3 -> cmp3 LT cmp4 | cmp4
cmp4 -> cmp4 GE cmp5 | cmp5
cmp5 -> cmp5 GT cmp6 | cmp6
cmp6 -> iexp ADD iexp' | iexp'
iexp' -> iexp' SUB iexp2 | iexp2
iexp2 -> iexp2 MUL iexp3 | iexp3
iexp3 -> iexp3 DIV iexp4 | iexp4
iexp4 -> iexp4 MOD iexp5 | iexp5
iexp5 -> ADD NUM | UMINUS NUM | IDENTIFIER | LPAREN expr RPAREN
```

## AST Datatype definition

The AST is defined slightly differently than mentioned in the assignment. Namely,
the AST uses lists too rather than merely a tree structure. This makes representing
sequences of commands and variable definitions much easier. The type definition
of the AST is as follows:

```
structure DataTypes =
struct 
    datatype PROG  = PROG of (DEC list)*(CMD list)
    and      DEC   = INT of string | BOOL of string 
    and      CMD   = RD of string | WR of EXPR | WH of EXPR*(CMD list) | 
                     ITE of EXPR*(CMD list)*(CMD list) | SET of string*EXPR
    and      EXPR  = ADD of EXPR*EXPR | SUB of EXPR*EXPR | 
                     MUL of EXPR*EXPR | DIV of EXPR*EXPR | 
                     MOD of EXPR*EXPR | NUM of int | REF of string |
                     OR of EXPR*EXPR | AND of EXPR*EXPR | NOT of EXPR |
                     LT of EXPR*EXPR | GT of EXPR*EXPR | GE of EXPR*EXPR |
                     LE of EXPR*EXPR | EQ of EXPR*EXPR | NE of EXPR*EXPR |
                     TRUE | FALSE
end;
```

A While program's AST root node is `PROG`, which has a list of declarations and 
a list of commands. A Declaration can be either an int, or a boolean, with an 
identifier. A command is as specified in the EBNF specification. Expressions
are simple binary operations (unary in the case of NOT) that combine both integer
and boolean expressions. This is done for several reasons, which are mentioned 
in § other design decisions.

## Syntax Directed Translation

The Semantic rules for the grammar are as follows (this can also be interpreted
from the YACC file). Each semantic declaration represents the root of the AST
generated by that rule.

NOTE: the expressions in capitals inside the semantic rules represent the datatypes
of the nodes, rather than the tokens. There are some name clashes (INT, BOOL are
both tokens and node datatypes). In practice, this is (messily?) rectified by
prefixing `TOK_` to all the tokens and leaving the AST datatypes as is to 
avoid collisions

NOTE 2: the definitions of `prependAll` and `makeVarList` are given in § Other
Implementation Decisions. In short, `prependAll` prepends all the variable declations
in that line (a line may have multiple variable declarations, eg `var x,y,z: int`)
to the main variable list, and `makeVarList` constructs that list of variable
declarations from a list of identifiers

```
prog -> PROGRAM IDENTIFIER BLOCKSTART declist cmdseq { PROG (declist, cmdseq) }

declist -> dec SEMICOLON declist { prependAll dec declist }
         | ε                     { [] }
dec -> VAR varlist COLON INT  { makeVarList varlist INT }
     | VAR varlist COLON BOOL { makeVarList varlist BOOL }
varlist -> IDENTIFIER COMMA varlist { IDENTIFIER.value :: varlist }
         | IDENTIFIER               { [IDENTIFIER.value] }

cmdseq -> LBRACE cmdlist RBRACE { cmdlist }
cmdlist -> cmd SEMICOLON cmdlist { cmd :: cmdlist }
         | ε                     { [] }
cmd -> READ IDENTIFIER { RD IDENTIFIR.value }
     | WRITE expr      { WR expr }
     | IDENTIFIER ASSIGN expr { SET (IDENTIFIER.value,expr) }
     | IF expr THEN cmdseq ELSE cmdseq ENDIF { ITE (expr,cmdseq1,cmdseq2) }
     | WHILE expr DO cmdseq ENDWH { WH (expr,cmdseq) }

expr -> expr OR bexp { OR (expr, bexp) }
      | bexp { bexp }
bexp -> bexp AND bexp' { AND (bexp, bexp') }
      | bexp' { bexp' }
bexp' -> TRUE {TRUE}
      | FALSE {FALSE}
      | NOT bexp' {NOT bexp'}
      | cmp  {cmp}
      | iexp {iexp}
cmp -> cmp EQ cmp' {EQ (cmp,cmp')}
     | cmp' {cmp'}
cmp' -> cmp' NE cmp2 {NE (cmp',cmp2)}
     | cmp2 {cmp2}
cmp2 -> cmp2 LE cmp3 {LE (cmp2,cmp3)}
     | cmp3 {cmp3}
cmp3 -> cmp3 LT cmp4 {LT (cmp3,cmp4)}
     | cmp4 {cmp4}
cmp4 -> cmp4 GE cmp5 {GE (cmp4,cmp5)}
     | cmp5 {cmp5}
cmp5 -> cmp5 GT cmp6 {GT (cmp5,cmp6)}
     | cmp6 {cmp6}
cmp6 -> iexp ADD iexp' {ADD (iexp,iexp')}
     | iexp' {iexp'}
iexp' -> iexp' SUB iexp2 {SUB (iexp',iexp2)}
     | iexp2 {iexp2}
iexp2 -> iexp2 MUL iexp3 {MUL (iexp2,iexp3)}
     | iexp3 {iexp3}
iexp3 -> iexp3 DIV iexp4 {DIV (iexp3,iexp4)}
     | iexp4 {iexp4}
iexp4 -> iexp4 MOD iexp5 {MOD (iexp4,iexp5)}
     | iexp5 {iexp5}
iexp5 -> ADD NUM {NUM NUM.value}
     | UMINUS NUM {NUM (-1*NUM.value)}
     | IDENTIFIER {REF IDENTIFIER.value}
     | LPAREN expr RPAREN {expr}
```

## Auxiliary Functions and Data
The `DataTypes` structure defined above was used across the parser and lexer. 
`glue.sml` defines some glue code that ties in the lexer and parser to get them
to work together, and `compiler.sml` contains the main While compiler that is
used to compile source files. Files are passed in by calling the function 
`While.compile "<filename>";`. Compilation is handled by `while.cm`, a compilation
manager file, which is invoked by typing in `CM.make "while.cm";`. 

## Usage
open up the SML interpreter:

```sml```

Set the control print depth to a larger number (this allows seeing the printed tree)

```- Control.Print.printDepth := 100;```

Compile the lex/yacc files using CM.make:

```- CM.make "while.cm";```

After successfully compiling, call the compiler on the file whose AST is
to be generated

```While.compile "<filename>";```

If all goes well, you should see an output similar to the following (this is 
the output for `test_prog.while`

```
val it =
  PROG
    ([INT "x",INT "y",BOOL "z"],
     [SET ("x",NUM 5),RD "y",
      ITE
        (EQ (ADD (REF "x",REF "y"),NUM 120),[SET ("z",TRUE)],
         [SET ("z",FALSE)]),WR (REF "y")]) : ?.DataTypes.PROG
```

## Other Design Decisions


## Other Implementation Decisions


## Acknowledgements
Most of the work here used the framework and design for the pi-calculus parser
in the [User's Guide to ML-Lex and ML-Yacc](http://rogerprice.org/ug/ug.pdf) by 
[Roger Price](http://rogerprice.org/).  

